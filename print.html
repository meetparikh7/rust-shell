<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Shell</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Command parsing</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Simple command execution</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">4.</strong> Background jobs</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">5.</strong> Signal handling</a></li><li class="chapter-item expanded "><a href="extras.html"><strong aria-hidden="true">6.</strong> Extras</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust Shell</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>I aim to make a small bash-like shell in Rust both as a learning exercise and for fun!</p>
<p>I am also documenting this as a tutorial for others to follow! The prerequisites for this tutorial would be a basic knowledge of some low-level programming language like C/C++ or Rust.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h2>
<ul>
<li>Make the project directory - <code>mkdir rust-shell &amp;&amp; cd rust-shell</code></li>
<li>Init the project - <code>cargo init</code> - <code>cargo</code> is Rust's inbuilt package manager (like <code>npm</code>)</li>
<li>Run the project - <code>cargo run</code>. This should print &quot;Hello, world!&quot;</li>
<li>(I followed an additional step after this to setup this tutorial)</li>
</ul>
<h2 id="accepting-input"><a class="header" href="#accepting-input">Accepting input</a></h2>
<p>Now lets try to accept a bit of input and echo it back</p>
<p>Modify <code>src/main.rs</code> to:</p>
<pre><pre class="playground"><code class="language-rust">// Import read_line and flush
use std::io::{self, Write};

fn main() {
    // loop defines an infinite loop a.k.a. while (true)
    loop {
        // Create a mutable string
        let mut command = String::new();

        // print and flush the output for the prompt, ignore the `expect` method for now
        print!(&quot;$ &quot;);
        io::stdout().flush().expect(&quot;Failed to write prompt&quot;);

        // Read the input, ignore the `expect` method for now
        io::stdin()
            .read_line(&amp;mut command)
            .expect(&quot;Failed to read line&quot;);

        // If command is exit break from the loop
        if command.trim() == &quot;exit&quot; {
            break;
        };

        // Print the entered command
        println!(&quot;You entered: {}&quot;, command);
    }
}
</code></pre></pre>
<h2 id="note-about-result-and-expect"><a class="header" href="#note-about-result-and-expect">Note about <code>Result</code> and <code>expect</code></a></h2>
<p>This is Rust's way of exception handling.</p>
<p><strong>TLDR</strong> we want to <code>panic!</code> and quit the program if the methods return an <code>Err</code>, else continue</p>
<p>Rust's exception system might be slightly new to C++ users, but I will try to summarize it here.</p>
<ul>
<li>If you think your method can throw an error, you must return a <code>Result&lt;T, E&gt;</code> instead of <code>T</code> where <code>T</code> is the type you intended to return initially and <code>E</code> is the error type (say <code>std::invalid_argument</code> from C++)</li>
<li>A <code>Result&lt;T, E&gt;</code> is either a <code>Ok(T)</code> or an <code>Err(E)</code>. <code>T</code> and <code>E</code> can be any types.</li>
<li>So the return type for <code>flush</code> is <code>Result&lt;()&gt;</code>. (<code>()</code> is the <code>void</code> type.)</li>
<li>i.e. it either returns <code>Ok</code> or <code>Err</code></li>
<li>We want to cause a unrecoverable runtime error when we cant flust the stdout due to some system reason</li>
<li>You may chose to <code>panic!</code> for unrecoverable runtime errors, which quits the program instantly</li>
<li><code>expect(str)</code> is a helper method in <code>Result</code>, which calls <code>panic!(str)</code> if an <code>Err</code> was returned from the method or continues otherwise</li>
</ul>
<p>You can read more about this from the <a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html">Rust Book</a></p>
<h1 id="command-parsing"><a class="header" href="#command-parsing">Command parsing</a></h1>
<p>Lets parse the command now and echo back the parsed command!</p>
<h2 id="tokenizing"><a class="header" href="#tokenizing">Tokenizing</a></h2>
<blockquote>
<p>A lexical token or simply token is a string with an assigned and thus identified meaning. It is structured as a pair consisting of a token name and an optional token value. The token name is a category of lexical unit.</p>
<p>-- <a href="https://en.wikipedia.org/wiki/Lexical_analysis#Token"><cite>Wikipedia</cite></a></p>
</blockquote>
<p>Lets break down a command into a list of individual tokens.</p>
<p>Since we are coding quite a simple shell, we dont have token types, all of them are strings! Note we are not going to be entirely like bash and adopting a simplified approach.</p>
<p>Lets also not handle new lines and other escaped control characters except space and quotes</p>
<p>Lets look at some examples of what our tokenization should look like</p>
<table><thead><tr><th>Example Description</th><th>Command</th><th>Tokens</th></tr></thead><tbody>
<tr><td>single token</td><td><code>echo</code></td><td><code>echo</code></td></tr>
<tr><td>multiple tokens</td><td><code>echo a b</code></td><td><code>echo</code>, <code>a</code>, <code>b</code></td></tr>
<tr><td>quotes</td><td><code>echo &quot;a b&quot;</code></td><td><code>echo</code>, <code>a b</code></td></tr>
<tr><td>multiple quotes</td><td><code>echo &quot;a b&quot; &quot;c&quot;</code></td><td><code>echo</code>, <code>a b</code>, <code>c</code></td></tr>
<tr><td>escaped quotes</td><td><code>echo &quot;a \&quot; b&quot; \&quot;x\&quot;</code></td><td><code>echo</code>, <code>a &quot; b</code>, <code>&quot;x&quot;</code></td></tr>
<tr><td>escaped spaces</td><td><code>echo a\ b</code></td><td><code>echo</code>, <code>a b</code></td></tr>
<tr><td>complex</td><td><code>NAME=&quot;&lt;Your name&gt;&quot; echo Hello $NAME</code></td><td><code>NAME=&lt;Your name&gt;</code>, <code>echo</code>, <code>Hello</code>, <code>$NAME</code></td></tr>
</tbody></table>
<h2 id="parser-module"><a class="header" href="#parser-module">Parser module</a></h2>
<p>We want to keep out code neat. So lets split the parser module. Splitting in Rust is very easy:</p>
<p>Add this to <code>main.rs</code></p>
<pre><code>mod parser;
</code></pre>
<p>This defines that there is a as of now undefined module parser. You could have defined it here using <code>mod parser { &lt;code here&gt; }</code>. However if you leave it like this, Rust will try to find a file <code>&lt;module_name&gt;.rs</code>. You will see how to define the module in the same file below</p>
<p>So let's write <code>parser.rs</code></p>
<pre><code>pub fn parse(s: &amp;str) -&gt; Option&lt;Vec&lt;String&gt;&gt; {
    Some(vec![String::from(s)])
}
</code></pre>
<p>This defines a public function in the module which parses a string and returns a vector of these string tokens</p>
<p>You will have noticed that a lot of stuff ends with <code>!</code>. These are macros in Rust, which help us use syntax sugar which can otherwise get cumbersome to write. <code>vec![*]</code> constructs a new vector from the elements listed.</p>
<p>And now use it in <code>main.rs</code> by changing the line which printed the command to</p>
<pre><code>// Print the parsed command
println!(&quot;You entered: {:?}&quot;, parser::parse(command.trim()));
</code></pre>
<h2 id="statements-and-expressions"><a class="header" href="#statements-and-expressions">Statements and expressions</a></h2>
<p>Most things in rust are expressions and not statements. And if you write an expression at the end (without a <code>;</code>) it would be returned.</p>
<p>This explains how <code>vec![s]</code> is equivalent to <code>return vec![s]</code> since it is the last expression of the function.</p>
<p>This also works for <code>if</code> statements, which serve as ternary operators and if/else blocks.</p>
<h2 id="a-note-about-the--and-ownership"><a class="header" href="#a-note-about-the--and-ownership">A note about the <code>&amp;</code> and ownership</a></h2>
<p>You will have noticed a lot of places using <code>&amp;</code>, <code>&amp;mut</code>, etc. I cant do this section justice and would recommend reading the <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">ownership section</a> from the book for this. This is really what sets rust apart! So I do recommend reading it</p>
<h2 id="option"><a class="header" href="#option"><code>Option</code>?</a></h2>
<p>An <code>Option&lt;T&gt;</code> is a type which is either <code>Some(T)</code> or <code>None</code>. We will return <code>None</code> when the input is erroneous or else a <code>Vec</code> of <code>String</code></p>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit tests</a></h2>
<p>Now that we have documented what we want, lets go ahead and do some <a href="https://en.wikipedia.org/wiki/Behavior-driven_development">BDD</a> and write some unit tests!</p>
<p>Add the following to the <code>parser.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn tokenization() {
        assert_eq!(parse(&quot;echo&quot;), Some(vec![&quot;echo&quot;]));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that the <code>tests</code> module is not public and hence cannot be used by <code>main</code>. (A public module is defined using <code>pub mod</code>)</p>
<p><code>unwrap</code> is a helper method in <code>Option</code> which causes a <code>panic!</code> if the type is <code>None</code> or else returns the</p>
<p>Run <code>cargo test</code> to see this test pass!</p>
<p>Now go on and add the other tests. Note that you will have to escape <code>\</code> and <code>&quot;</code> with additional <code>\</code></p>
<h2 id="the-shlex-crate"><a class="header" href="#the-shlex-crate">The shlex crate</a></h2>
<p>This kind of tokenization is provided by the <code>shlex</code> module in Python. What if we could get this utility in Rust!</p>
<p>So lets visit <a href="https://crates.io">crates.io</a> and search for <code>shlex</code>. And voila, we find the <a href="https://crates.io/crates/shlex">shlex crate</a>.</p>
<p>Adding this to our project, is as easy as copying the line from the page to <code>Cargo.toml</code> in the <code>[dependencies]</code> section</p>
<p>Now lets use this in parser. This is the final source code for <code>parser.rs</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use shlex;

pub fn parse(s: &amp;str) -&gt; Option&lt;Vec&lt;String&gt;&gt; {
    shlex::split(s)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn tokenization() {
        assert_eq!(parse(&quot;echo&quot;), Some(vec![&quot;echo&quot;]));
        assert_eq!(parse(&quot;echo a b&quot;), Some(vec![&quot;echo&quot;, &quot;a&quot;, &quot;b&quot;]));
        assert_eq!(parse(&quot;echo \&quot;a b\&quot;&quot;), Some(vec![&quot;echo&quot;, &quot;a b&quot;]));
        assert_eq!(
            parse(&quot;echo \&quot;a b\&quot; \&quot;c\&quot;&quot;),
            Some(vec![&quot;echo&quot;, &quot;a b&quot;, &quot;c&quot;])
        );
        assert_eq!(
            parse(&quot;echo \&quot;a \\\&quot; b\&quot; \\\&quot;x\\\&quot;&quot;),
            Some(vec![&quot;echo&quot;, &quot;a \&quot; b&quot;, &quot;\&quot;x\&quot;&quot;])
        );
        assert_eq!(parse(&quot;echo a\\ b&quot;), Some(vec![&quot;echo&quot;, &quot;a b&quot;]));
        assert_eq!(
            parse(&quot;NAME=\&quot;&lt;Your name&gt;\&quot; echo Hello $NAME&quot;),
            Some(vec![&quot;NAME=&lt;Your name&gt;&quot;, &quot;echo&quot;, &quot;Hello&quot;, &quot;$NAME&quot;])
        );
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="simple-command-execution"><a class="header" href="#simple-command-execution">Simple command execution</a></h1>
<p>Lets now try to execute the command</p>
<p>The docs for the <a href="https://doc.rust-lang.org/std/process/index.html"><code>std::process</code></a> module tell us exactly how to do this</p>
<p>We create a new module called <code>executor</code> and add the following code there:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::process::{Command, Stdio};

pub struct TaskManager {}

impl TaskManager {
    pub fn new() -&gt; TaskManager {
        TaskManager {}
    }

    pub fn execute(&amp;mut self, command: Vec&lt;String&gt;) {
        if let Some((base_cmd, args)) = command.split_first() {
            // Create a new command
            let mut cmd = Command::new(base_cmd);
            // Add args to the command
            for arg in args {
                cmd.arg(arg);
            }

            // Invoke command with stdin and stdout of parent, i.e. the shell
            let invoked_cmd = cmd
                .stdin(Stdio::inherit())
                .stdout(Stdio::inherit())
                .spawn()
                .expect(&amp;format!(&quot;Failed to start {}&quot;, base_cmd));

            // Wait for command to finish
            invoked_cmd
                .wait_with_output()
                .expect(&amp;format!(&quot;Failed to wait for {}&quot;, base_cmd));
        } else {
            // Pass as empty command
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Stepping over it line-by-line:</p>
<ul>
<li>We create an empty struct called <code>TaskManager</code> and have an <code>execute</code> method in it. This struct will come handy later.</li>
<li>Here, we note we use <code>split_first</code> to get a tuple telling us the base command and the remaining args</li>
<li>We first create a new mutable <code>std::process::Command</code></li>
<li>Then we add all the args one-by-one using <code>.arg</code> method. Doing this one-by-one will allow us to easily substitute variables in the future</li>
<li>Finally, we invoke it saying inherit <code>stdin</code> and <code>stdout</code> from the parent. This means if the shell was run interactively, the stdin and stfout will be interactive but if file redirection was done while launching the shell itself, then it will use the redirected input/output.</li>
<li>Finally, we wait for it to finish and then return.</li>
</ul>
<p>We modify <code>main.rs</code> to run this <code>execute</code> method instead of printing the tokenized command:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod executor;

// ...

let mut task_manager = executor::TaskManager::new();

// ...

match parser::parse(command.trim()) {
    Some(parsed_command) =&gt; task_manager.execute(parsed_command),
    None =&gt; println!(&quot;Invalid command&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="background-jobs"><a class="header" href="#background-jobs">Background jobs</a></h1>
<p>This is a slightly meaty chapter</p>
<h2 id="taskmanagers-state"><a class="header" href="#taskmanagers-state">TaskManager's state</a></h2>
<p>First lets give our task manager the abilitiy to track background jobs. We will use a <code>HashMap</code> for this.</p>
<p>The <code>bg_jobs</code> HashMap tracks each child process and <code>cur_job</code> is used as an incrementing id</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

pub struct TaskManager {
    bg_jobs: HashMap&lt;i64, Child&gt;,
    cur_job: i64,
}

impl TaskManager {
    pub fn new() -&gt; TaskManager {
        // pass for now
        TaskManager {
            bg_jobs: HashMap::new(),
            cur_job: 0,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="detecting-background-jobs"><a class="header" href="#detecting-background-jobs">Detecting background jobs</a></h2>
<p>We say a job is to be run in background if it ends with an ampersand, e.g. <code>sleep 10 &amp;</code></p>
<details>
<summary>Click here for code</summary>
So, we add in the execute block
<pre><code class="language-rust no_run noplayground">            // Detect if command ends with ampersand
            let is_bg_job = args.len() &gt; 0
                &amp;&amp; match args.last().unwrap().as_str() {
                    &quot;&amp;&quot; =&gt; true,
                    _ =&gt; false,
                };
            if is_bg_job {
                // Remove the ampersand from the args
                args = &amp;args[0..args.len() - 1]
            }
</code></pre>
</details>
<h2 id="running-a-process-in-background"><a class="header" href="#running-a-process-in-background">Running a process in background</a></h2>
<p>After spawning the process, if it is a background process, we simply add it to the <code>bg_jobs</code> HashMap with <code>cur_job</code> as the key and increment the the <code>cur_job</code>:</p>
<pre><code class="language-rust no_run noplayground">if is_bg_job {
    self.cur_job += 1;
    self.bg_jobs.insert(self.cur_job, invoked_cmd);
    println!(&quot;Started bg job {}&quot;, self.cur_job);
}
</code></pre>
<h2 id="bringing-a-background-process-back-to-the-front-using-fg"><a class="header" href="#bringing-a-background-process-back-to-the-front-using-fg">Bringing a background process back to the front using <code>fg</code></a></h2>
<p>We want to bring a process back to the front on running <code>fg &lt;job_id&gt;</code>. We move the child process out of the hashmap using the <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.remove"><code>HashMap::remove</code></a> method.</p>
<pre><code class="language-rust no_run noplayground">    fn fg(&amp;mut self, args: &amp;[String]) {
        let job = args[0].parse::&lt;i64&gt;().unwrap();
        // Move the child_process out of the hashmap
        let child_process = self.bg_jobs.remove(&amp;job).unwrap();
        // Wait for command to finish
        self.run_process_in_fg(child_process);
    }
</code></pre>
<p>We make sure that this method executes by putting at the top of teh execute method</p>
<pre><code class="language-rust no_run noplayground">if base_cmd == &quot;fg&quot; {
    return self.fg(args);
}
</code></pre>
<h2 id="checking-on-background-jobs"><a class="header" href="#checking-on-background-jobs">Checking on background jobs</a></h2>
<p>We want a <code>jobs</code> command to print the list of the currently running jobs</p>
<pre><code class="language-rust no_run noplayground">    fn jobs(&amp;mut self, _args: &amp;[String]) {
        let mut toremove: Vec&lt;i64&gt; = vec![];
        for (job, child_process) in self.bg_jobs.iter_mut() {
            match child_process
                .try_wait()
                .expect(&amp;format!(&quot;Was unable to check status of bg job {}&quot;, job))
            {
                Some(status) =&gt; {
                    println!(&quot;Job {} exited with status {}&quot;, job, status);
                    toremove.push(*job);
                }
                None =&gt; println!(&quot;Job {} still running&quot;, job),
            }
        }
        for job in toremove {
            self.bg_jobs.remove(&amp;job);
        }
    }
</code></pre>
<p>Here, we first get mutable eferences to the child processes and call <code>ChildProcess::try_wait</code> on these. These allows us to know if the process has terminated or not. We also remove all terminated processes from the hashmap of jobs</p>
<h1 id="signal-handling"><a class="header" href="#signal-handling">Signal handling</a></h1>
<p>We want to handle simple UNIX signals. For learning we will handle <code>SIGTSTP</code> a.k.a. <code>Ctrl+Z</code> should send current process to background</p>
<p>Enter the <a href="https://docs.rs/signal-hook/0.3.6/signal_hook/"><code>signal-hook</code></a> crate, which handles UNIX signals in a Rust-friendly manner.</p>
<p>If you want to know more about the library, you can read the author's <a href="https://vorner.github.io/2018/06/28/signal-hook.html">blog post</a>. You can learn more about why UNIX signals isn't a great API <a href="https://ldpreload.com/blog/signalfd-is-useless">here</a>.</p>
<p>Add <code>signal-hook = &quot;0.3.6&quot;</code> as a dependency in <code>Cargo.toml</code></p>
<h2 id="registering-signal-handlers"><a class="header" href="#registering-signal-handlers">Registering signal handlers</a></h2>
<p>The following lines allow us to register a <code>SIGTSTP</code> signal handler which will set the &quot;flag variable&quot; <code>shall_stop_process</code></p>
<pre><code class="language-rust no_run noplayground">use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};

let shall_stop_process = Arc::new(AtomicBool::new(false));
signal_hook::flag::register(signal_hook::consts::SIGTSTP, Arc::clone(&amp;shall_stop_process)).unwrap();
</code></pre>
<p>This uses an <a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html"><code>AtomicBool</code></a> as the signal handling occurs in another thread.</p>
<p>An <code>Arc</code> container is used by the <code>signal-hook</code> API, which is a thread-safe reference counted smart pointer - Read <a href="https://doc.rust-lang.org/book/ch15-04-rc.html">Ch 15.4 Rc</a> and <a href="https://doc.rust-lang.org/book/ch16-03-shared-state.html#atomic-reference-counting-with-arct">Arc section in Ch 16.3</a> in the Rust Book for more information.</p>
<h2 id="using-this-in-the-code"><a class="header" href="#using-this-in-the-code">Using this in the code</a></h2>
<p>Lets look at this new method <code>run_process_in_fg</code> which waits for a process registering <code>SIGTSTP</code> handler</p>
<pre><code class="language-rust no_run noplayground">    fn run_process_in_fg(&amp;mut self, mut child_process: Child) {
        let shall_stop_process = Arc::new(AtomicBool::new(false));
        signal_hook::flag::register(
            signal_hook::consts::SIGTSTP,
            Arc::clone(&amp;shall_stop_process),
        )
        .unwrap();

        loop {
            if shall_stop_process.load(Ordering::Relaxed) {
                self.cur_job += 1;
                self.bg_jobs.insert(self.cur_job, child_process);
                println!(&quot;Now running as background job {}&quot;, self.cur_job);
                break;
            }
            // Wait for command to finish
            match child_process
                .try_wait()
                .expect(&amp;format!(&quot;Failed to wait for current job&quot;))
            {
                Some(_status) =&gt; break,
                _ =&gt; (),
            }
        }
    }
</code></pre>
<p>We then use this helper method in both <code>execute</code> and <code>fg</code></p>
<h1 id="extras"><a class="header" href="#extras">Extras</a></h1>
<h2 id="cd"><a class="header" href="#cd"><code>cd</code></a></h2>
<p>Our shell lacks a basic change directory command right now, lets add that:</p>
<p>Add to the TaskManager struct <code>cur_dir: PathBuf</code></p>
<p>Add a <code>cd</code> method and use it in <code>execute</code></p>
<pre><code class="language-rust no_run noplayground">    fn cd(&amp;mut self, args: &amp;[String]) {
        let new_dir = std::path::Path::new(&amp;args[0]);
        let new_dir_pathbuf;
        if new_dir.is_relative() {
            new_dir_pathbuf = self.cur_dir.join(new_dir);
        } else {
            new_dir_pathbuf = new_dir.to_path_buf();
        }
        self.cur_dir = new_dir_pathbuf;
    }
</code></pre>
<p>Then use <code>.current_dir(self.cur_dir.as_path())</code> in the command builder to launch the new command in this path.</p>
<h2 id="future"><a class="header" href="#future">Future</a></h2>
<p>This isnt complete and a lot more things can be done for learning.</p>
<p>Other features that can be added are:</p>
<ul>
<li>I/O redirection and pipes</li>
<li>Variable expansion and environment variables</li>
<li>Minor tweaks like <code>~</code> in paths</li>
<li>More signal handling for a friendlier shell</li>
<li>More shell built-ins</li>
</ul>
<p>However I am satisfied with what I have learnt so far! I hope you learnt something new today too after reading this series!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
